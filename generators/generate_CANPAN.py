# Generate descriptor file for CANPAN/CANPAN3 modules.
# Use this script to avoid duplication and reduce maintenance.

import json
import sys
from sys import argv
from datetime import datetime, timezone
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-v", "--version", help="Firmware version")
parser.add_argument("-p", "--processor", help="Processor type")
args = parser.parse_args()

# default capabilities
moduleName="CANPAN"
LEDs=32
switches=32
processorSeries="K"

if args.processor == "23":
    # PIC18F27Q83
    processorSeries = "Q"
elif args.processor is not None:
    print(f"Unsupported processor ID ({args.processor})")
    exit(1)

if args.version == "1Y" or args.version == "4C":
    nothing = True
elif args.version == "5a":
    moduleName = "CANPAN3"


now = datetime.now(timezone.utc)
datestring = f"{now.year}{now.month:02}{now.day:02}{now.hour:02}{now.minute:02}"

commandLine = " ".join(argv)
data = {
    "generated": f"Generated by {commandLine}",
    "timestamp": datestring,
    "moduleName": moduleName,
    "numberOfChannels": LEDs + switches,
    "channelNames": {}
}
for ch in range(1, LEDs + 1):
    data["channelNames"][str(ch)] = f"LED {ch}"
for ch in range(1, switches + 1):
    data["channelNames"][str(ch + LEDs)] = f"Switch {ch}"

startupActions = []
if args.version == "1Y":
    startupActions = [
        {"label": "0 - Send all current taught event states", "value": 0},
        {"label": "1 - Do nothing", "value": 1},
        {"label": "2 - Set all taught states to ON", "value": 2}
    ]
elif args.version == "4C":
    startupActions = [
        {"label": "0 - Send all current taught event states", "value": 0},
        {"label": "1 - Do nothing", "value": 1},
        {"label": "2 - Set all taught states to according to switches", "value": 2},
        {"label": "3 - Set all taught states to OFF", "value": 3}
    ]
elif args.version == "5a":
    startupActions = [
        {"label": "0 - Restore switch states", "value": 0},
        {"label": "1 - Do nothing", "value": 1},
        {"label": "2 - Restore switch states and LED states", "value": 2},
        {"label": "3 - Restore LED states", "value": 3}
    ]
nodeVariables = [
    {
        "type": "NodeVariableSelect",
        "nodeVariableIndex": 1,
        "displayTitle": "Startup Actions",
        "options": startupActions
    }
]
if args.version == "5a":
    nodeVariables.extend([
        {
            "displayTitle": "Startup Event Delay",
            "type": "NodeVariableNumber",
            "nodeVariableIndex": 67,
            "displayUnits": "seconds"
        },
        {
            "displayTitle": "LED Flash rate",
            "type": "NodeVariableSlider",
            "nodeVariableIndex": 2,
            "displayUnits": "ms",
            "displayScale": 16.13
        }
    ])
    ledItems = []
    for led in range(1, LEDs + 1):
        ledItems.append(
            {
                "displayTitle": f"${{channel{led}}}",
                "type": "NodeVariableSlider",
                "nodeVariableIndex": 2 + led,
                "max": 31
            }
        )
    nodeVariables.append(
        {
            "displayTitle": "LED Brightness",
            "type": "NodeVariableGroup",
            "groupItems": ledItems
        }
    )
    switchPairItems = []
    for sw in range(1, switches, 2):
        switchPairItems.append(
            {
                "displayTitle": f"${{channel{LEDs + sw}}} & ${{channel{LEDs + sw + 1}}}",
                "type": "NodeVariableBitSingle",
                "nodeVariableIndex": 2 + LEDs +sw,
                "bit": 0
            }
        )
    nodeVariables.append(
        {
            "displayTitle": "Switch Pairing",
            "type": "NodeVariableGroup",
            "groupItems": switchPairItems
        }
    )
data["nodeVariables"] = nodeVariables

eventVariables = [
]
if args.version != "5a":
    eventVariables.append(
        {
            "displayTitle": "Event Type",
            "type": "EventVariableSelect",
            "eventVariableIndex": 1,
            "options": [
                { "value": 0, "label": "Consumed Event" },
                { "value": 1, "label": "Produced Event" },
                { "value": 2, "label": "Start of Day" },
                { "value": 3, "label": "Self SoD" }
            ]
        }
    )
else:
    eventVariables.append(
        {
            "displayTitle": "Start of Day",
            "type": "EventVariableBitSingle",
            "eventVariableIndex": 1,
            "bit": 1
        }
    )
prodEvent = {
    "displayTitle": "Produced Event",
    "type": "EventVariableGroup"
}
if args.version != "5a":
    prodEvent["visibilityLogic"] = {
        "ev": 1,
        "equals": 1
    }
switchOptions = [{"label": "None", "value": 0}]
for sw in range(1, switches+1):
    switchOptions.append({"label": f"${{channel{LEDs + sw}}}", "value": sw})
if args.version == "5a":
    switchOptions.append({"label": "Start up event", "value": switches + 1})
prodEvent["groupItems"] = [
    {
        "displayTitle": "Switch",
        "type": "EventVariableSelect",
        "eventVariableIndex": 2,
        "options": switchOptions,
    },
    {
        "displayTitle": "Mode",
        "type": "EventVariableSelect",
        "eventVariableIndex": 3,
        "bitMask": 15,
        "options": [
            {"value": 0, "label": "None"},
            {"value": 1, "label": "ON/OFF"},
            {"value": 3, "label": "OFF/ON (inverted)"},
            {"value": 4, "label": "ON only"},
            {"value": 6, "label": "OFF only"},
            {"value": 8, "label": "Push ON/Push OFF"}
        ],
        "visibilityLogic": {"JLL": {"and": [
            {">": [{"EV": 2}, 0]},
            {"<": [{"EV": 2}, 32]}
        ]}}
    }
]
if args.version != "5a":
    prodEvent["groupItems"].extend([
        {
            "displayTitle": "Set LEDs",
            "type": "EventVariableBitSingle",
            "eventVariableIndex": 3,
            "bit": 4
        },
        {
            "displayTitle": "Send Short Event",
            "displaySubTitle": "Set this when teaching a produced short events",
            "type": "EventVariableBitSingle",
            "eventVariableIndex": 3,
            "bit": 5
        }
    ])
eventVariables.append(prodEvent)

if args.version != "5a":
    selfSodEventOptions = [{"label": "None", "value": 0}]
    for sw in range(1, switches + 1):
        selfSodEventOptions.append({"label": f"${{channel{LEDs + sw}}}", "value": sw})
    eventVariables.extend([
        {
            "displayTitle": "Produced Self SoD Event",
            "type": "EventVariableGroup",
            "visibilityLogic": {
                "ev": 1,
                "equals": 3
            },
            "groupItems": [
                {
                    "displayTitle": "Switch",
                    "type": "EventVariableSelect",
                    "eventVariableIndex": 2,
                    "options": selfSodEventOptions
                },
                {
                    "displayTitle": "Mode",
                    "type": "EventVariableSelect",
                    "eventVariableIndex": 3,
                    "bitMask": 15,
                    "options": [
                        { "value": 0, "label": "None" },
                        { "value": 1, "label": "ON/OFF" },
                        { "value": 3, "label": "OFF/ON (inverted)" },
                        { "value": 4, "label": "ON only" },
                        { "value": 6, "label": "OFF only" },
                        { "value": 8, "label": "Push ON/Push OFF" }
                    ],
                    "visibilityLogic": { "JLL": { "or" : [
                        { ">" : [ {"EV" : 2 }, 0 ]},
                        { "<" : [ {"EV" : 2 }, 32 ]}
                    ]}}
                },
                {
                    "displayTitle": "Send Short Event",
                    "displaySubTitle": "Set this when teaching a produced short events",
                    "type": "EventVariableBitSingle",
                    "eventVariableIndex": 3,
                    "bit": 5
                }
            ]
        }
    ])

ledEvents = {
    "displayTitle": "LEDs",
    "type": "EventVariableGroup"
}
if args.version != "5a":
    ledEvents["visibilityLogic"] = {
        "evBit": {"index": 3, "bit": 4},
        "equals": 1
    }
ledEvents["groupItems"] = [
    {
        "displayTitle": "LED Action",
        "type": "EventVariableSelect",
        "eventVariableIndex": 13,
        "options": [
            {"value":   0, "label": "Undefined (0)"},
            {"value": 255, "label": "Normal"},
            {"value": 254, "label": "ON Only"},
            {"value": 253, "label": "OFF Only"},
            {"value": 248, "label": "Flash"}
        ]
    }
]
for led in range(1, LEDs + 1):
    ledEvents["groupItems"].append(
        {
            "displayTitle": f"${{channel{led}}}",
            "type": "EventVariableGroup",
            "groupItems": [
                {
                    "displayTitle": "Active",
                    "type": "EventVariableBitSingle",
                    "eventVariableIndex": 5+int((led-1)/8),
                    "bit": (led - 1) % 8
                },
                {
                    "displayTitle": "Invert",
                    "type": "EventVariableBitSingle",
                    "eventVariableIndex": 9 + int((led - 1) / 8),
                    "bit": (led - 1) % 8,
                    "visibilityLogic": {"JLL": {"==": [{"EVbit": [5 + int((led - 1) / 8), (led - 1) % 8]}, True]}}
                }
            ]
        }
    )
eventVariables.append(ledEvents)

if args.version != "5a":
    consEvents = {
        "displayTitle": "Consumed Event",
        "type": "EventVariableGroup",
        "visibilityLogic": {
            "ev": 1,
            "equals": 0
        },
        "groupItems": [
            {
                "displayTitle": "LED Action",
                "type": "EventVariableSelect",
                "eventVariableIndex": 13,
                "options": [
                    {"value": 0, "label": "Undefined (0)"},
                    {"value": 255, "label": "Normal"},
                    {"value": 254, "label": "ON Only"},
                    {"value": 253, "label": "OFF Only"},
                    {"value": 248, "label": "Flash"}
                ]
            }
        ]
    }
    for led in range(1, LEDs + 1):
        consEvents["groupItems"].append(
            {
                "displayTitle": f"${{channel{led}}}",
                "type": "EventVariableGroup",
                "groupItems": [
                    {
                        "displayTitle": "Active",
                        "type": "EventVariableBitSingle",
                        "eventVariableIndex": 5+int((led-1)/8),
                        "bit": (led - 1) % 8
                    },
                    {
                        "displayTitle": "Invert",
                        "type": "EventVariableBitSingle",
                        "eventVariableIndex": 9 + int((led - 1) / 8),
                        "bit": (led - 1) % 8,
                        "visibilityLogic": {"JLL": {"==": [{"EVbit": [5 + int((led - 1) / 8), (led - 1) % 8]}, True]}}
                    }
                ]
            }
        )
    eventVariables.append(consEvents)

data["eventVariables"] = eventVariables

json.dump(data, sys.stdout, indent=2)
print("")
